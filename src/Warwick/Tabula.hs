--------------------------------------------------------------------------------
-- Haskell bindings for the Tabula API                                        --
-- Copyright 2018 Michael B. Gale (m.gale@warwick.ac.uk)                      --
--------------------------------------------------------------------------------

module Warwick.Tabula (
    --module Warwick.Tabula.API,
    --module Warwick.Tabula.Internal,
    module Warwick.Tabula.Coursework,

    TabulaInstance(..),

    Tabula(..),

    ModuleCode(..),
    AssignmentID(..),

    TabulaResponse(..),

    withTabula,

    listAssignments,
    listSubmissions,

    downloadSubmission
) where

--------------------------------------------------------------------------------

import Control.Monad.Catch (catch, throwM)
import Control.Monad.State
import Control.Monad.Except
--import Control.Monad.Throw

--import Data.Text
import qualified Data.ByteString as BS
import qualified Data.ByteString.Internal as BS
import Data.Text.Encoding (encodeUtf8)
import qualified Data.HashMap.Lazy as HM

import Data.Conduit
import Data.Conduit.Binary hiding (mapM_)

import Data.Aeson

import Network.HTTP.Conduit
import Network.HTTP.Simple
import qualified Network.HTTP.Client.Conduit as C

import Servant.API.BasicAuth
import Servant.Client

import Warwick.Tabula.Config
import Warwick.Tabula.Types
import Warwick.Tabula.Error
import Warwick.Tabula.Coursework
import Warwick.Tabula.API
import qualified Warwick.Tabula.Internal as I

-------------------------------------------------------------------------------

-- | Enumerates Tabula instances.
data TabulaInstance = Sandbox | Live | CustomInstance BaseUrl

-- | The URL to the Tabula API.
liveURL :: BaseUrl
liveURL = BaseUrl Https "tabula.warwick.ac.uk" 443 "/api/v1"

-- | The URL to the Tabula Sandbox API.
sandboxURL :: BaseUrl
sandboxURL = BaseUrl Https "tabula-sandbox.warwick.ac.uk" 443 "/api/v1"

-- | Determines the location of a given Tabula instance.
urlForInstance :: TabulaInstance -> BaseUrl
urlForInstance Sandbox              = sandboxURL
urlForInstance Live                 = liveURL
urlForInstance (CustomInstance url) = url

-------------------------------------------------------------------------------

-- | Represents the configuration for a Tabula session.
data TabulaSession = TabulaSession {
    sessionAuthData :: BasicAuthData,
    sessionManager  :: Manager,
    sessionURL      :: BaseUrl
}

-- | Represents computations involving the Tabula API.
type Tabula = StateT TabulaSession (ExceptT TabulaError ClientM)

tabulaAuthData :: Tabula BasicAuthData
tabulaAuthData = gets sessionAuthData

tabulaManager :: Tabula Manager
tabulaManager = gets sessionManager

tabulaURL :: Tabula BaseUrl
tabulaURL = gets sessionURL

-- | `withTabula` @instance @config @action runs the computation @action
-- by connecting to @instance with the configuration specified by @config.
withTabula ::
    TabulaInstance -> TabulaConfig -> Tabula a -> IO (Either TabulaError a)
withTabula inst (TabulaConfig {..}) m = do
    manager <- newManager tlsManagerSettings

    let auth = BasicAuthData
                    (encodeUtf8 tabulaUsername)
                    (encodeUtf8 tabulaPassword)
        url  = urlForInstance inst
        env  = ClientEnv manager url
        sesh = TabulaSession auth manager url

    r <- runClientM (runExceptT $ evalStateT m sesh) env

    case r of
        Left serr -> return $ Left $ TransportError serr
        Right res -> return res

-------------------------------------------------------------------------------

-- | Client functions generated by servant throw exceptions when a server
-- returns a non-2xx status code. `handle` @m catches exceptions which are
-- thrown when @m is executed and tries to convert them into a Tabula response.
handle :: (FromJSON a, HasPayload a)
       => ClientM (TabulaResponse a) -> Tabula (TabulaResponse a)
handle m = lift $ lift $ m `catch` \(e :: ServantError) -> case e of
   FailureResponse {..} -> case decode responseBody of
       Nothing -> throwM e
       Just r  -> return r
   _                    -> throwM e

listAssignments ::
    ModuleCode -> Maybe AcademicYear -> Tabula (TabulaResponse [Assignment])
listAssignments mc yr = do
    authData <- tabulaAuthData
    handle $ I.listAssignments authData mc yr

listSubmissions ::
    ModuleCode -> AssignmentID -> Tabula (TabulaResponse (HM.HashMap String (Maybe Submission)))
listSubmissions mc aid = do
    authData <- tabulaAuthData
    handle $ I.listSubmissions authData mc (unAssignmentID aid)

buildDownloadURL :: BaseUrl
                 -> ModuleCode
                 -> AssignmentID
                 -> Submission
                 -> FilePath
                 -> BS.ByteString
buildDownloadURL url mc aid sub fn = BS.concat
    [ BS.packChars $ baseUrlPath url
    , "/module/"
    , moduleCode mc
    , "/assignments/"
    , toASCIIBytes $ unAssignmentID aid
    , "/submissions/"
    , BS.packChars (submissionID sub)
    , "/"
    , BS.packChars fn
    ]

downloadSubmission :: String
                   -> ModuleCode
                   -> AssignmentID
                   -> Submission
                   -> FilePath
                   -> FilePath
                   -> Tabula ()
downloadSubmission sid mc aid sub fn out = do
    manager            <- tabulaManager
    baseURL            <- tabulaURL
    BasicAuthData {..} <- tabulaAuthData
    let url = buildDownloadURL baseURL mc aid sub fn
        request
            = applyBasicAuth basicAuthUsername basicAuthPassword
            $ setRequestMethod "GET"
            $ setRequestPath url
            $ setRequestSecure True
            $ setRequestPort (baseUrlPort baseURL)
            $ setRequestHost (BS.packChars $ baseUrlHost baseURL)
            $ defaultRequest
    runConduitRes $ do
         response <- http request manager
         C.responseBody response $$+- sinkFile out
    return ()

-------------------------------------------------------------------------------
